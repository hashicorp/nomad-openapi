/*
Nomad

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.1.4
Contact: support@hashicorp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

// JobsApiService JobsApi service
type JobsApiService service

type ApiDeleteJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
	purge *bool
	global *bool
}

// Filters results based on the specified region.
func (r ApiDeleteJobRequest) Region(region string) ApiDeleteJobRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiDeleteJobRequest) Namespace(namespace string) ApiDeleteJobRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiDeleteJobRequest) XNomadToken(xNomadToken string) ApiDeleteJobRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiDeleteJobRequest) IdempotencyToken(idempotencyToken string) ApiDeleteJobRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}
// Boolean flag indicating whether to purge allocations of the job after deleting.
func (r ApiDeleteJobRequest) Purge(purge bool) ApiDeleteJobRequest {
	r.purge = &purge
	return r
}
// Boolean flag indicating whether the operation should apply to all instances of the job globally.
func (r ApiDeleteJobRequest) Global(global bool) ApiDeleteJobRequest {
	r.global = &global
	return r
}

func (r ApiDeleteJobRequest) Execute() (*JobDeregisterResponse, *http.Response, error) {
	return r.ApiService.DeleteJobExecute(r)
}

/*
DeleteJob Method for DeleteJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiDeleteJobRequest
*/
func (a *JobsApiService) DeleteJob(ctx context.Context, jobName string) ApiDeleteJobRequest {
	return ApiDeleteJobRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobDeregisterResponse
func (a *JobsApiService) DeleteJobExecute(r ApiDeleteJobRequest) (*JobDeregisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobDeregisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.DeleteJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	if r.purge != nil {
		localVarQueryParams.Add("purge", parameterToString(*r.purge, ""))
	}
	if r.global != nil {
		localVarQueryParams.Add("global", parameterToString(*r.global, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobRequest) Region(region string) ApiGetJobRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobRequest) Namespace(namespace string) ApiGetJobRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobRequest) Index(index int32) ApiGetJobRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobRequest) Wait(wait string) ApiGetJobRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobRequest) Stale(stale string) ApiGetJobRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobRequest) Prefix(prefix string) ApiGetJobRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobRequest) XNomadToken(xNomadToken string) ApiGetJobRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobRequest) PerPage(perPage int32) ApiGetJobRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobRequest) NextToken(nextToken string) ApiGetJobRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.GetJobExecute(r)
}

/*
GetJob Method for GetJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobRequest
*/
func (a *JobsApiService) GetJob(ctx context.Context, jobName string) ApiGetJobRequest {
	return ApiGetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return Job
func (a *JobsApiService) GetJobExecute(r ApiGetJobRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobAllocationsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	all *bool
}

// Filters results based on the specified region.
func (r ApiGetJobAllocationsRequest) Region(region string) ApiGetJobAllocationsRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobAllocationsRequest) Namespace(namespace string) ApiGetJobAllocationsRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobAllocationsRequest) Index(index int32) ApiGetJobAllocationsRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobAllocationsRequest) Wait(wait string) ApiGetJobAllocationsRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobAllocationsRequest) Stale(stale string) ApiGetJobAllocationsRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobAllocationsRequest) Prefix(prefix string) ApiGetJobAllocationsRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobAllocationsRequest) XNomadToken(xNomadToken string) ApiGetJobAllocationsRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobAllocationsRequest) PerPage(perPage int32) ApiGetJobAllocationsRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobAllocationsRequest) NextToken(nextToken string) ApiGetJobAllocationsRequest {
	r.nextToken = &nextToken
	return r
}
// Specifies whether the list of allocations should include allocations from a previously registered job with the same ID. This is possible if the job is deregistered and reregistered.
func (r ApiGetJobAllocationsRequest) All(all bool) ApiGetJobAllocationsRequest {
	r.all = &all
	return r
}

func (r ApiGetJobAllocationsRequest) Execute() ([]AllocationListStub, *http.Response, error) {
	return r.ApiService.GetJobAllocationsExecute(r)
}

/*
GetJobAllocations Method for GetJobAllocations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobAllocationsRequest
*/
func (a *JobsApiService) GetJobAllocations(ctx context.Context, jobName string) ApiGetJobAllocationsRequest {
	return ApiGetJobAllocationsRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return []AllocationListStub
func (a *JobsApiService) GetJobAllocationsExecute(r ApiGetJobAllocationsRequest) ([]AllocationListStub, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AllocationListStub
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobAllocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/allocations"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.all != nil {
		localVarQueryParams.Add("all", parameterToString(*r.all, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobDeploymentRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobDeploymentRequest) Region(region string) ApiGetJobDeploymentRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobDeploymentRequest) Namespace(namespace string) ApiGetJobDeploymentRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobDeploymentRequest) Index(index int32) ApiGetJobDeploymentRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobDeploymentRequest) Wait(wait string) ApiGetJobDeploymentRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobDeploymentRequest) Stale(stale string) ApiGetJobDeploymentRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobDeploymentRequest) Prefix(prefix string) ApiGetJobDeploymentRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobDeploymentRequest) XNomadToken(xNomadToken string) ApiGetJobDeploymentRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobDeploymentRequest) PerPage(perPage int32) ApiGetJobDeploymentRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobDeploymentRequest) NextToken(nextToken string) ApiGetJobDeploymentRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobDeploymentRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.GetJobDeploymentExecute(r)
}

/*
GetJobDeployment Method for GetJobDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobDeploymentRequest
*/
func (a *JobsApiService) GetJobDeployment(ctx context.Context, jobName string) ApiGetJobDeploymentRequest {
	return ApiGetJobDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return Deployment
func (a *JobsApiService) GetJobDeploymentExecute(r ApiGetJobDeploymentRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/deployment"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobDeploymentsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	all *int32
}

// Filters results based on the specified region.
func (r ApiGetJobDeploymentsRequest) Region(region string) ApiGetJobDeploymentsRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobDeploymentsRequest) Namespace(namespace string) ApiGetJobDeploymentsRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobDeploymentsRequest) Index(index int32) ApiGetJobDeploymentsRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobDeploymentsRequest) Wait(wait string) ApiGetJobDeploymentsRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobDeploymentsRequest) Stale(stale string) ApiGetJobDeploymentsRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobDeploymentsRequest) Prefix(prefix string) ApiGetJobDeploymentsRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobDeploymentsRequest) XNomadToken(xNomadToken string) ApiGetJobDeploymentsRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobDeploymentsRequest) PerPage(perPage int32) ApiGetJobDeploymentsRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobDeploymentsRequest) NextToken(nextToken string) ApiGetJobDeploymentsRequest {
	r.nextToken = &nextToken
	return r
}
// Flag indicating whether to constrain by job creation index or not.
func (r ApiGetJobDeploymentsRequest) All(all int32) ApiGetJobDeploymentsRequest {
	r.all = &all
	return r
}

func (r ApiGetJobDeploymentsRequest) Execute() ([]Deployment, *http.Response, error) {
	return r.ApiService.GetJobDeploymentsExecute(r)
}

/*
GetJobDeployments Method for GetJobDeployments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobDeploymentsRequest
*/
func (a *JobsApiService) GetJobDeployments(ctx context.Context, jobName string) ApiGetJobDeploymentsRequest {
	return ApiGetJobDeploymentsRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return []Deployment
func (a *JobsApiService) GetJobDeploymentsExecute(r ApiGetJobDeploymentsRequest) ([]Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobDeployments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/deployments"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.all != nil {
		localVarQueryParams.Add("all", parameterToString(*r.all, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobEvaluationsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobEvaluationsRequest) Region(region string) ApiGetJobEvaluationsRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobEvaluationsRequest) Namespace(namespace string) ApiGetJobEvaluationsRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobEvaluationsRequest) Index(index int32) ApiGetJobEvaluationsRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobEvaluationsRequest) Wait(wait string) ApiGetJobEvaluationsRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobEvaluationsRequest) Stale(stale string) ApiGetJobEvaluationsRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobEvaluationsRequest) Prefix(prefix string) ApiGetJobEvaluationsRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobEvaluationsRequest) XNomadToken(xNomadToken string) ApiGetJobEvaluationsRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobEvaluationsRequest) PerPage(perPage int32) ApiGetJobEvaluationsRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobEvaluationsRequest) NextToken(nextToken string) ApiGetJobEvaluationsRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobEvaluationsRequest) Execute() ([]Evaluation, *http.Response, error) {
	return r.ApiService.GetJobEvaluationsExecute(r)
}

/*
GetJobEvaluations Method for GetJobEvaluations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobEvaluationsRequest
*/
func (a *JobsApiService) GetJobEvaluations(ctx context.Context, jobName string) ApiGetJobEvaluationsRequest {
	return ApiGetJobEvaluationsRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return []Evaluation
func (a *JobsApiService) GetJobEvaluationsExecute(r ApiGetJobEvaluationsRequest) ([]Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobEvaluations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/evaluations"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobScaleStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobScaleStatusRequest) Region(region string) ApiGetJobScaleStatusRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobScaleStatusRequest) Namespace(namespace string) ApiGetJobScaleStatusRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobScaleStatusRequest) Index(index int32) ApiGetJobScaleStatusRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobScaleStatusRequest) Wait(wait string) ApiGetJobScaleStatusRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobScaleStatusRequest) Stale(stale string) ApiGetJobScaleStatusRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobScaleStatusRequest) Prefix(prefix string) ApiGetJobScaleStatusRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobScaleStatusRequest) XNomadToken(xNomadToken string) ApiGetJobScaleStatusRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobScaleStatusRequest) PerPage(perPage int32) ApiGetJobScaleStatusRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobScaleStatusRequest) NextToken(nextToken string) ApiGetJobScaleStatusRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobScaleStatusRequest) Execute() (*JobScaleStatusResponse, *http.Response, error) {
	return r.ApiService.GetJobScaleStatusExecute(r)
}

/*
GetJobScaleStatus Method for GetJobScaleStatus

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobScaleStatusRequest
*/
func (a *JobsApiService) GetJobScaleStatus(ctx context.Context, jobName string) ApiGetJobScaleStatusRequest {
	return ApiGetJobScaleStatusRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobScaleStatusResponse
func (a *JobsApiService) GetJobScaleStatusExecute(r ApiGetJobScaleStatusRequest) (*JobScaleStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobScaleStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobScaleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/scale"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobSummaryRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobSummaryRequest) Region(region string) ApiGetJobSummaryRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobSummaryRequest) Namespace(namespace string) ApiGetJobSummaryRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobSummaryRequest) Index(index int32) ApiGetJobSummaryRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobSummaryRequest) Wait(wait string) ApiGetJobSummaryRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobSummaryRequest) Stale(stale string) ApiGetJobSummaryRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobSummaryRequest) Prefix(prefix string) ApiGetJobSummaryRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobSummaryRequest) XNomadToken(xNomadToken string) ApiGetJobSummaryRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobSummaryRequest) PerPage(perPage int32) ApiGetJobSummaryRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobSummaryRequest) NextToken(nextToken string) ApiGetJobSummaryRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobSummaryRequest) Execute() (*JobSummary, *http.Response, error) {
	return r.ApiService.GetJobSummaryExecute(r)
}

/*
GetJobSummary Method for GetJobSummary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobSummaryRequest
*/
func (a *JobsApiService) GetJobSummary(ctx context.Context, jobName string) ApiGetJobSummaryRequest {
	return ApiGetJobSummaryRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobSummary
func (a *JobsApiService) GetJobSummaryExecute(r ApiGetJobSummaryRequest) (*JobSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobVersionsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
	diffs *bool
}

// Filters results based on the specified region.
func (r ApiGetJobVersionsRequest) Region(region string) ApiGetJobVersionsRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobVersionsRequest) Namespace(namespace string) ApiGetJobVersionsRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobVersionsRequest) Index(index int32) ApiGetJobVersionsRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobVersionsRequest) Wait(wait string) ApiGetJobVersionsRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobVersionsRequest) Stale(stale string) ApiGetJobVersionsRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobVersionsRequest) Prefix(prefix string) ApiGetJobVersionsRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobVersionsRequest) XNomadToken(xNomadToken string) ApiGetJobVersionsRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobVersionsRequest) PerPage(perPage int32) ApiGetJobVersionsRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobVersionsRequest) NextToken(nextToken string) ApiGetJobVersionsRequest {
	r.nextToken = &nextToken
	return r
}
// Boolean flag indicating whether to compute job diffs.
func (r ApiGetJobVersionsRequest) Diffs(diffs bool) ApiGetJobVersionsRequest {
	r.diffs = &diffs
	return r
}

func (r ApiGetJobVersionsRequest) Execute() (*JobVersionsResponse, *http.Response, error) {
	return r.ApiService.GetJobVersionsExecute(r)
}

/*
GetJobVersions Method for GetJobVersions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiGetJobVersionsRequest
*/
func (a *JobsApiService) GetJobVersions(ctx context.Context, jobName string) ApiGetJobVersionsRequest {
	return ApiGetJobVersionsRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobVersionsResponse
func (a *JobsApiService) GetJobVersionsExecute(r ApiGetJobVersionsRequest) (*JobVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	if r.diffs != nil {
		localVarQueryParams.Add("diffs", parameterToString(*r.diffs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJobsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	region *string
	namespace *string
	index *int32
	wait *string
	stale *string
	prefix *string
	xNomadToken *string
	perPage *int32
	nextToken *string
}

// Filters results based on the specified region.
func (r ApiGetJobsRequest) Region(region string) ApiGetJobsRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiGetJobsRequest) Namespace(namespace string) ApiGetJobsRequest {
	r.namespace = &namespace
	return r
}
// If set, wait until query exceeds given index. Must be provided with WaitParam.
func (r ApiGetJobsRequest) Index(index int32) ApiGetJobsRequest {
	r.index = &index
	return r
}
// Provided with IndexParam to wait for change.
func (r ApiGetJobsRequest) Wait(wait string) ApiGetJobsRequest {
	r.wait = &wait
	return r
}
// If present, results will include stale reads.
func (r ApiGetJobsRequest) Stale(stale string) ApiGetJobsRequest {
	r.stale = &stale
	return r
}
// Constrains results to jobs that start with the defined prefix
func (r ApiGetJobsRequest) Prefix(prefix string) ApiGetJobsRequest {
	r.prefix = &prefix
	return r
}
// A Nomad ACL token.
func (r ApiGetJobsRequest) XNomadToken(xNomadToken string) ApiGetJobsRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Maximum number of results to return.
func (r ApiGetJobsRequest) PerPage(perPage int32) ApiGetJobsRequest {
	r.perPage = &perPage
	return r
}
// Indicates where to start paging for queries that support pagination.
func (r ApiGetJobsRequest) NextToken(nextToken string) ApiGetJobsRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiGetJobsRequest) Execute() ([]JobListStub, *http.Response, error) {
	return r.ApiService.GetJobsExecute(r)
}

/*
GetJobs Method for GetJobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJobsRequest
*/
func (a *JobsApiService) GetJobs(ctx context.Context) ApiGetJobsRequest {
	return ApiGetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JobListStub
func (a *JobsApiService) GetJobsExecute(r ApiGetJobsRequest) ([]JobListStub, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobListStub
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.wait != nil {
		localVarQueryParams.Add("wait", parameterToString(*r.wait, ""))
	}
	if r.stale != nil {
		localVarQueryParams.Add("stale", parameterToString(*r.stale, ""))
	}
	if r.prefix != nil {
		localVarQueryParams.Add("prefix", parameterToString(*r.prefix, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per_page", parameterToString(*r.perPage, ""))
	}
	if r.nextToken != nil {
		localVarQueryParams.Add("next_token", parameterToString(*r.nextToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.index != nil {
		localVarHeaderParams["index"] = parameterToString(*r.index, "")
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobRegisterRequest *JobRegisterRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobRequest) JobRegisterRequest(jobRegisterRequest JobRegisterRequest) ApiPostJobRequest {
	r.jobRegisterRequest = &jobRegisterRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobRequest) Region(region string) ApiPostJobRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobRequest) Namespace(namespace string) ApiPostJobRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobRequest) XNomadToken(xNomadToken string) ApiPostJobRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobRequest) IdempotencyToken(idempotencyToken string) ApiPostJobRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobRequest) Execute() (*JobRegisterResponse, *http.Response, error) {
	return r.ApiService.PostJobExecute(r)
}

/*
PostJob Method for PostJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobRequest
*/
func (a *JobsApiService) PostJob(ctx context.Context, jobName string) ApiPostJobRequest {
	return ApiPostJobRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobRegisterResponse
func (a *JobsApiService) PostJobExecute(r ApiPostJobRequest) (*JobRegisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobRegisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobRegisterRequest == nil {
		return localVarReturnValue, nil, reportError("jobRegisterRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobRegisterRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobDispatchRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobDispatchRequest *JobDispatchRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobDispatchRequest) JobDispatchRequest(jobDispatchRequest JobDispatchRequest) ApiPostJobDispatchRequest {
	r.jobDispatchRequest = &jobDispatchRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobDispatchRequest) Region(region string) ApiPostJobDispatchRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobDispatchRequest) Namespace(namespace string) ApiPostJobDispatchRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobDispatchRequest) XNomadToken(xNomadToken string) ApiPostJobDispatchRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobDispatchRequest) IdempotencyToken(idempotencyToken string) ApiPostJobDispatchRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobDispatchRequest) Execute() (*JobDispatchResponse, *http.Response, error) {
	return r.ApiService.PostJobDispatchExecute(r)
}

/*
PostJobDispatch Method for PostJobDispatch

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobDispatchRequest
*/
func (a *JobsApiService) PostJobDispatch(ctx context.Context, jobName string) ApiPostJobDispatchRequest {
	return ApiPostJobDispatchRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobDispatchResponse
func (a *JobsApiService) PostJobDispatchExecute(r ApiPostJobDispatchRequest) (*JobDispatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobDispatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobDispatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/dispatch"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobDispatchRequest == nil {
		return localVarReturnValue, nil, reportError("jobDispatchRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobDispatchRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobEvaluateRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobEvaluateRequest *JobEvaluateRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobEvaluateRequest) JobEvaluateRequest(jobEvaluateRequest JobEvaluateRequest) ApiPostJobEvaluateRequest {
	r.jobEvaluateRequest = &jobEvaluateRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobEvaluateRequest) Region(region string) ApiPostJobEvaluateRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobEvaluateRequest) Namespace(namespace string) ApiPostJobEvaluateRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobEvaluateRequest) XNomadToken(xNomadToken string) ApiPostJobEvaluateRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobEvaluateRequest) IdempotencyToken(idempotencyToken string) ApiPostJobEvaluateRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobEvaluateRequest) Execute() (*JobRegisterResponse, *http.Response, error) {
	return r.ApiService.PostJobEvaluateExecute(r)
}

/*
PostJobEvaluate Method for PostJobEvaluate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobEvaluateRequest
*/
func (a *JobsApiService) PostJobEvaluate(ctx context.Context, jobName string) ApiPostJobEvaluateRequest {
	return ApiPostJobEvaluateRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobRegisterResponse
func (a *JobsApiService) PostJobEvaluateExecute(r ApiPostJobEvaluateRequest) (*JobRegisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobRegisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobEvaluate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/evaluate"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobEvaluateRequest == nil {
		return localVarReturnValue, nil, reportError("jobEvaluateRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobEvaluateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobParseRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobsParseRequest *JobsParseRequest
}

func (r ApiPostJobParseRequest) JobsParseRequest(jobsParseRequest JobsParseRequest) ApiPostJobParseRequest {
	r.jobsParseRequest = &jobsParseRequest
	return r
}

func (r ApiPostJobParseRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.PostJobParseExecute(r)
}

/*
PostJobParse Method for PostJobParse

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostJobParseRequest
*/
func (a *JobsApiService) PostJobParse(ctx context.Context) ApiPostJobParseRequest {
	return ApiPostJobParseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Job
func (a *JobsApiService) PostJobParseExecute(r ApiPostJobParseRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobParse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/parse"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobsParseRequest == nil {
		return localVarReturnValue, nil, reportError("jobsParseRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jobsParseRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobPeriodicForceRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

// Filters results based on the specified region.
func (r ApiPostJobPeriodicForceRequest) Region(region string) ApiPostJobPeriodicForceRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobPeriodicForceRequest) Namespace(namespace string) ApiPostJobPeriodicForceRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobPeriodicForceRequest) XNomadToken(xNomadToken string) ApiPostJobPeriodicForceRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobPeriodicForceRequest) IdempotencyToken(idempotencyToken string) ApiPostJobPeriodicForceRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobPeriodicForceRequest) Execute() (*PeriodicForceResponse, *http.Response, error) {
	return r.ApiService.PostJobPeriodicForceExecute(r)
}

/*
PostJobPeriodicForce Method for PostJobPeriodicForce

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobPeriodicForceRequest
*/
func (a *JobsApiService) PostJobPeriodicForce(ctx context.Context, jobName string) ApiPostJobPeriodicForceRequest {
	return ApiPostJobPeriodicForceRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return PeriodicForceResponse
func (a *JobsApiService) PostJobPeriodicForceExecute(r ApiPostJobPeriodicForceRequest) (*PeriodicForceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PeriodicForceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobPeriodicForce")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/periodic/force"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobPlanRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobPlanRequest *JobPlanRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobPlanRequest) JobPlanRequest(jobPlanRequest JobPlanRequest) ApiPostJobPlanRequest {
	r.jobPlanRequest = &jobPlanRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobPlanRequest) Region(region string) ApiPostJobPlanRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobPlanRequest) Namespace(namespace string) ApiPostJobPlanRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobPlanRequest) XNomadToken(xNomadToken string) ApiPostJobPlanRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobPlanRequest) IdempotencyToken(idempotencyToken string) ApiPostJobPlanRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobPlanRequest) Execute() (*JobPlanResponse, *http.Response, error) {
	return r.ApiService.PostJobPlanExecute(r)
}

/*
PostJobPlan Method for PostJobPlan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobPlanRequest
*/
func (a *JobsApiService) PostJobPlan(ctx context.Context, jobName string) ApiPostJobPlanRequest {
	return ApiPostJobPlanRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobPlanResponse
func (a *JobsApiService) PostJobPlanExecute(r ApiPostJobPlanRequest) (*JobPlanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobPlanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/plan"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobPlanRequest == nil {
		return localVarReturnValue, nil, reportError("jobPlanRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobPlanRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobRevertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobRevertRequest *JobRevertRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobRevertRequest) JobRevertRequest(jobRevertRequest JobRevertRequest) ApiPostJobRevertRequest {
	r.jobRevertRequest = &jobRevertRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobRevertRequest) Region(region string) ApiPostJobRevertRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobRevertRequest) Namespace(namespace string) ApiPostJobRevertRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobRevertRequest) XNomadToken(xNomadToken string) ApiPostJobRevertRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobRevertRequest) IdempotencyToken(idempotencyToken string) ApiPostJobRevertRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobRevertRequest) Execute() (*JobRegisterResponse, *http.Response, error) {
	return r.ApiService.PostJobRevertExecute(r)
}

/*
PostJobRevert Method for PostJobRevert

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobRevertRequest
*/
func (a *JobsApiService) PostJobRevert(ctx context.Context, jobName string) ApiPostJobRevertRequest {
	return ApiPostJobRevertRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobRegisterResponse
func (a *JobsApiService) PostJobRevertExecute(r ApiPostJobRevertRequest) (*JobRegisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobRegisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobRevert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/revert"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobRevertRequest == nil {
		return localVarReturnValue, nil, reportError("jobRevertRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobRevertRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobScalingRequestRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	scalingRequest *ScalingRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobScalingRequestRequest) ScalingRequest(scalingRequest ScalingRequest) ApiPostJobScalingRequestRequest {
	r.scalingRequest = &scalingRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobScalingRequestRequest) Region(region string) ApiPostJobScalingRequestRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobScalingRequestRequest) Namespace(namespace string) ApiPostJobScalingRequestRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobScalingRequestRequest) XNomadToken(xNomadToken string) ApiPostJobScalingRequestRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobScalingRequestRequest) IdempotencyToken(idempotencyToken string) ApiPostJobScalingRequestRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobScalingRequestRequest) Execute() (*JobRegisterResponse, *http.Response, error) {
	return r.ApiService.PostJobScalingRequestExecute(r)
}

/*
PostJobScalingRequest Method for PostJobScalingRequest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobScalingRequestRequest
*/
func (a *JobsApiService) PostJobScalingRequest(ctx context.Context, jobName string) ApiPostJobScalingRequestRequest {
	return ApiPostJobScalingRequestRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobRegisterResponse
func (a *JobsApiService) PostJobScalingRequestExecute(r ApiPostJobScalingRequestRequest) (*JobRegisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobRegisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobScalingRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/scale"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scalingRequest == nil {
		return localVarReturnValue, nil, reportError("scalingRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.scalingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobStabilityRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobName string
	jobStabilityRequest *JobStabilityRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobStabilityRequest) JobStabilityRequest(jobStabilityRequest JobStabilityRequest) ApiPostJobStabilityRequest {
	r.jobStabilityRequest = &jobStabilityRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobStabilityRequest) Region(region string) ApiPostJobStabilityRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobStabilityRequest) Namespace(namespace string) ApiPostJobStabilityRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobStabilityRequest) XNomadToken(xNomadToken string) ApiPostJobStabilityRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobStabilityRequest) IdempotencyToken(idempotencyToken string) ApiPostJobStabilityRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobStabilityRequest) Execute() (*JobStabilityResponse, *http.Response, error) {
	return r.ApiService.PostJobStabilityExecute(r)
}

/*
PostJobStability Method for PostJobStability

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobName The job identifier.
 @return ApiPostJobStabilityRequest
*/
func (a *JobsApiService) PostJobStability(ctx context.Context, jobName string) ApiPostJobStabilityRequest {
	return ApiPostJobStabilityRequest{
		ApiService: a,
		ctx: ctx,
		jobName: jobName,
	}
}

// Execute executes the request
//  @return JobStabilityResponse
func (a *JobsApiService) PostJobStabilityExecute(r ApiPostJobStabilityRequest) (*JobStabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobStabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobStability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{jobName}/stable"
	localVarPath = strings.Replace(localVarPath, "{"+"jobName"+"}", url.PathEscape(parameterToString(r.jobName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobStabilityRequest == nil {
		return localVarReturnValue, nil, reportError("jobStabilityRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobStabilityRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostJobValidateRequestRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobValidateRequest *JobValidateRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiPostJobValidateRequestRequest) JobValidateRequest(jobValidateRequest JobValidateRequest) ApiPostJobValidateRequestRequest {
	r.jobValidateRequest = &jobValidateRequest
	return r
}
// Filters results based on the specified region.
func (r ApiPostJobValidateRequestRequest) Region(region string) ApiPostJobValidateRequestRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiPostJobValidateRequestRequest) Namespace(namespace string) ApiPostJobValidateRequestRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiPostJobValidateRequestRequest) XNomadToken(xNomadToken string) ApiPostJobValidateRequestRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiPostJobValidateRequestRequest) IdempotencyToken(idempotencyToken string) ApiPostJobValidateRequestRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiPostJobValidateRequestRequest) Execute() (*JobValidateResponse, *http.Response, error) {
	return r.ApiService.PostJobValidateRequestExecute(r)
}

/*
PostJobValidateRequest Method for PostJobValidateRequest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostJobValidateRequestRequest
*/
func (a *JobsApiService) PostJobValidateRequest(ctx context.Context) ApiPostJobValidateRequestRequest {
	return ApiPostJobValidateRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobValidateResponse
func (a *JobsApiService) PostJobValidateRequestExecute(r ApiPostJobValidateRequestRequest) (*JobValidateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobValidateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.PostJobValidateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/validate/job"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobValidateRequest == nil {
		return localVarReturnValue, nil, reportError("jobValidateRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobValidateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	jobRegisterRequest *JobRegisterRequest
	region *string
	namespace *string
	xNomadToken *string
	idempotencyToken *string
}

func (r ApiRegisterJobRequest) JobRegisterRequest(jobRegisterRequest JobRegisterRequest) ApiRegisterJobRequest {
	r.jobRegisterRequest = &jobRegisterRequest
	return r
}
// Filters results based on the specified region.
func (r ApiRegisterJobRequest) Region(region string) ApiRegisterJobRequest {
	r.region = &region
	return r
}
// Filters results based on the specified namespace.
func (r ApiRegisterJobRequest) Namespace(namespace string) ApiRegisterJobRequest {
	r.namespace = &namespace
	return r
}
// A Nomad ACL token.
func (r ApiRegisterJobRequest) XNomadToken(xNomadToken string) ApiRegisterJobRequest {
	r.xNomadToken = &xNomadToken
	return r
}
// Can be used to ensure operations are only run once.
func (r ApiRegisterJobRequest) IdempotencyToken(idempotencyToken string) ApiRegisterJobRequest {
	r.idempotencyToken = &idempotencyToken
	return r
}

func (r ApiRegisterJobRequest) Execute() (*JobRegisterResponse, *http.Response, error) {
	return r.ApiService.RegisterJobExecute(r)
}

/*
RegisterJob Method for RegisterJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRegisterJobRequest
*/
func (a *JobsApiService) RegisterJob(ctx context.Context) ApiRegisterJobRequest {
	return ApiRegisterJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return JobRegisterResponse
func (a *JobsApiService) RegisterJobExecute(r ApiRegisterJobRequest) (*JobRegisterResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobRegisterResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.RegisterJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.jobRegisterRequest == nil {
		return localVarReturnValue, nil, reportError("jobRegisterRequest is required and must be specified")
	}

	if r.region != nil {
		localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	}
	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.idempotencyToken != nil {
		localVarQueryParams.Add("idempotency_token", parameterToString(*r.idempotencyToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xNomadToken != nil {
		localVarHeaderParams["X-Nomad-Token"] = parameterToString(*r.xNomadToken, "")
	}
	// body params
	localVarPostBody = r.jobRegisterRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["X-Nomad-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Nomad-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
